#!/usr/bin/env python3

"""
Network utility functions for working with NetworkX and CX2 networks.
Uses standard ndex2 client library for CX2 conversions.
Provides functions for working with both NDEx and local CX2 files.
"""

import networkx as nx
import json
import os
import glob
from typing import Dict, List, Any, Set, Optional, Tuple, Union
from datetime import datetime
from ndex2.cx2 import CX2Network
from ndex2.cx2 import CX2NetworkXFactory, NetworkXToCX2NetworkFactory, RawCX2NetworkFactory

def cx2_to_networkx(cx2_network: CX2Network) -> nx.Graph:
    """
    Convert CX2 network to NetworkX graph using standard ndex2 library
    
    Args:
        cx2_network: CX2 network object
        
    Returns:
        NetworkX graph
    """
    # Use the standard CX2NetworkXFactory to convert CX2 to NetworkX
    converter = CX2NetworkXFactory()
    G = converter.get_graph(cx2_network)
    
    # Create a lookup from gene symbols to node IDs for compatibility with older code
    gene_to_id = {}
    
    # Add mappings from names/gene symbols to node IDs
    for node_id, attrs in G.nodes(data=True):
        # Get node name
        node_name = attrs.get('name', '')
        
        # Store gene symbol to node ID mapping if available
        if node_name:
            gene_to_id[node_name] = node_id
            
        # Also use GeneSymbol as a lookup if different from name
        gene_symbol = attrs.get('GeneSymbol', '')
        if gene_symbol and gene_symbol != node_name:
            gene_to_id[gene_symbol] = node_id
    
    # Store the gene symbol to ID mapping in graph metadata for compatibility
    G.graph['gene_to_id'] = gene_to_id
    
    return G

def networkx_to_cx2(G: nx.Graph) -> Dict:
    """
    Convert a NetworkX graph to a CX2 network in JSON format using standard ndex2 library.
    
    Args:
        G: NetworkX graph
        
    Returns:
        Dictionary in CX2 format
    """
    # Use the standard NetworkXToCX2NetworkFactory to convert NetworkX to CX2Network
    factory = NetworkXToCX2NetworkFactory()
    cx2_network = factory.get_cx2network(G)
    
    # Ensure we have a name
    if not cx2_network.get_name():
        cx2_network.set_name("Generated Network")
    
    # Add description if missing
    network_attrs = cx2_network.get_network_attributes()
    if 'description' not in network_attrs:
        cx2_network.set_network_attribute('description', "Network generated by algorithm")
    
    # Add version if missing
    if 'version' not in network_attrs:
        cx2_network.set_network_attribute('version', "1.0")
    
    # Make sure propagation_weight attribute is properly declared
    # This is important for preserving weights from the propagation algorithms
    attr_declarations = cx2_network.get_attribute_declarations()
    if 'nodes' in attr_declarations and 'propagation_weight' not in attr_declarations['nodes']:
        attr_declarations['nodes']['propagation_weight'] = {'d': 'double'}
        cx2_network.set_attribute_declarations(attr_declarations)
    
    # Get the full CX2 JSON representation
    cx2_data = cx2_network.to_cx2()
    
    # Ensure visualProperties are present if they're not included by the factory
    # This is important for preserving visual styles
    has_visual_props = False
    for item in cx2_data:
        if "visualProperties" in item:
            has_visual_props = True
            break
            
    if not has_visual_props:
        # Add default visualProperties section
        cx2_data.append({"visualEditorProperties": [{"properties": {
            "nodeSizeLocked": False,
            "arrowColorMatchesEdge": True,
            "nodeCustomGraphicsSizeSync": True
        }}]})
        
        cx2_data.append({"visualProperties": [{"default": {}}]})
    
    return cx2_data

def cx2_network_to_cx2_json(cx2_network: CX2Network) -> Dict:
    """
    Convert a CX2Network object to CX2 JSON format compatible with NDEx.
    
    Args:
        cx2_network: CX2Network object
        
    Returns:
        Dictionary in CX2 format
    """
    # Use the CX2Network's built-in to_cx2() method to get proper CX2 JSON
    return cx2_network.to_cx2()

def extract_subnetwork(G: nx.Graph, node_ids: List[str], include_connecting_edges: bool = True) -> nx.Graph:
    """
    Extract a subnetwork containing only specified nodes and optionally their connecting edges.
    
    Args:
        G: Full NetworkX graph
        node_ids: List of node IDs to include in the subnetwork
        include_connecting_edges: If True, include edges between selected nodes
        
    Returns:
        NetworkX subgraph with only the specified nodes and edges
    """
    # Convert node_ids to a set for faster lookup
    node_set = set(node_ids)
    
    # Filter to ensure all nodes exist in the graph
    existing_nodes = [n for n in node_ids if n in G]
    
    if include_connecting_edges:
        # Create a subgraph with the specified nodes and all edges between them
        subgraph = G.subgraph(existing_nodes).copy()
    else:
        # Create an empty graph with the same properties as G
        subgraph = nx.Graph()
        subgraph.graph = G.graph.copy()
        
        # Add only the specified nodes with their attributes
        for node_id in existing_nodes:
            subgraph.add_node(node_id, **G.nodes[node_id])
    
    return subgraph

def save_cx2_to_file(cx2_data: Union[Dict, CX2Network], output_path: str) -> None:
    """
    Save CX2 network data to a JSON file.
    
    Args:
        cx2_data: CX2 network data (either as a dict or CX2Network object)
        output_path: Path to save the file
        
    Returns:
        None
    """
    # Create output directory if it doesn't exist
    os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
    
    # Convert to dict if we received a CX2Network object
    if isinstance(cx2_data, CX2Network):
        cx2_data = cx2_data.to_cx2()
    
    with open(output_path, 'w') as f:
        json.dump(cx2_data, f, indent=2)
    print(f"Saved CX2 network to {output_path}")

def get_experimental_data_properties(G: nx.Graph) -> Dict[str, List[str]]:
    """
    Identify potential experimental data properties in the graph
    
    Args:
        G: NetworkX graph
        
    Returns:
        Dictionary of property groups and their property names
    """
    # Count occurrences of each property
    property_counts = {}
    numeric_properties = set()
    
    for node, attrs in G.nodes(data=True):
        for key, value in attrs.items():
            if key not in property_counts:
                property_counts[key] = 0
            property_counts[key] += 1
            
            # Check if property is numeric
            if isinstance(value, (int, float)) and not isinstance(value, bool):
                numeric_properties.add(key)
    
    # Categorize properties
    common_properties = set()
    experimental_properties = set()
    
    # Define known metadata properties that are not experimental data
    metadata_properties = {
        'id', 'name', 'GeneSymbol', 'x', 'y', 'type', 'represents', 
        'viral_protein', 'propagation_weight', 'node_type'
    }
    
    # Threshold for common properties (present in >70% of nodes)
    threshold = 0.7 * G.number_of_nodes()
    
    for prop, count in property_counts.items():
        if prop in metadata_properties:
            continue
            
        if count > threshold:
            common_properties.add(prop)
            
        if prop in numeric_properties and prop not in metadata_properties:
            experimental_properties.add(prop)
    
    # Group properties
    property_groups = {
        'common': list(common_properties),
        'experimental': list(experimental_properties),
        'propagation': ['propagation_weight'] if 'propagation_weight' in property_counts else []
    }
    
    return property_groups

def create_cx2_from_dict(cx2_dict: Dict) -> CX2Network:
    """
    Create a CX2Network object from a CX2 dictionary.
    
    Args:
        cx2_dict: Dictionary in CX2 format
        
    Returns:
        CX2Network object
    """
    # Use the RawCX2NetworkFactory to convert the dict to a CX2Network
    factory = RawCX2NetworkFactory()
    return factory.get_cx2network(cx2_dict)

def merge_visual_properties(target_cx2: Dict, source_cx2: Dict) -> Dict:
    """
    Merge visual properties from source CX2 network into target CX2 network.
    This is useful when creating a new network that should maintain the visual style of the original.
    
    Args:
        target_cx2: Target CX2 network data as dict
        source_cx2: Source CX2 network data as dict with visual properties to copy
        
    Returns:
        Updated target CX2 network with visual properties from source
    """
    # Find visual properties in source
    visual_props = None
    visual_editor_props = None
    
    for item in source_cx2:
        if "visualProperties" in item:
            visual_props = item["visualProperties"]
        elif "visualEditorProperties" in item:
            visual_editor_props = item["visualEditorProperties"]
    
    # Update target with source visual properties
    if visual_props:
        # Remove existing visual properties if any
        target_cx2 = [item for item in target_cx2 if "visualProperties" not in item]
        # Add visual properties from source
        target_cx2.append({"visualProperties": visual_props})
    
    if visual_editor_props:
        # Remove existing visual editor properties if any
        target_cx2 = [item for item in target_cx2 if "visualEditorProperties" not in item]
        # Add visual editor properties from source
        target_cx2.append({"visualEditorProperties": visual_editor_props})
    
    return target_cx2

# --- Functions for working with local CX2 files ---

def load_cx2_from_file(file_path: str) -> CX2Network:
    """
    Load a CX2 network from a file.
    
    Args:
        file_path: Path to the CX2 file
        
    Returns:
        CX2Network object
    """
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"CX2 file not found: {file_path}")
    
    # Load the file
    with open(file_path, 'r') as f:
        cx2_data = json.load(f)
    
    # Create CX2Network object
    factory = RawCX2NetworkFactory()
    return factory.get_cx2network(cx2_data)

def load_networkx_from_cx2_file(file_path: str) -> nx.Graph:
    """
    Load a NetworkX graph directly from a CX2 file.
    
    Args:
        file_path: Path to the CX2 file
        
    Returns:
        NetworkX graph
    """
    # Load CX2 network
    cx2_network = load_cx2_from_file(file_path)
    
    # Convert to NetworkX
    return cx2_to_networkx(cx2_network)

def find_cx2_files(directory: str, pattern: str = "*.cx2") -> List[str]:
    """
    Find all CX2 files in a directory matching a pattern.
    
    Args:
        directory: Directory to search
        pattern: Glob pattern to match files
        
    Returns:
        List of file paths
    """
    if not os.path.exists(directory):
        return []
    
    # Get all matching files
    file_pattern = os.path.join(directory, pattern)
    return glob.glob(file_pattern)

def find_latest_cx2_file(directory: str, pattern: str = "*.cx2") -> Optional[str]:
    """
    Find the most recently modified CX2 file in a directory.
    
    Args:
        directory: Directory to search
        pattern: Glob pattern to match files
        
    Returns:
        Path to the most recent file or None if not found
    """
    # Get all matching files
    files = find_cx2_files(directory, pattern)
    
    if not files:
        return None
    
    # Sort by modification time (newest first)
    files.sort(key=os.path.getmtime, reverse=True)
    
    return files[0]

def get_network_info(network_data: Union[str, CX2Network, nx.Graph, Dict]) -> Dict[str, Any]:
    """
    Get basic information about a network from various formats.
    
    Args:
        network_data: Network in one of the following formats:
            - Path to a CX2 file (str)
            - CX2Network object
            - NetworkX graph
            - CX2 data as dict
            
    Returns:
        Dictionary with network information
    """
    # Handle different input types
    if isinstance(network_data, str):
        # Assume it's a file path
        if not os.path.exists(network_data):
            raise FileNotFoundError(f"Network file not found: {network_data}")
        
        # Load from file
        with open(network_data, 'r') as f:
            cx2_data = json.load(f)
        
        # Create CX2Network object
        factory = RawCX2NetworkFactory()
        cx2_network = factory.get_cx2network(cx2_data)
        
    elif isinstance(network_data, CX2Network):
        # Already a CX2Network object
        cx2_network = network_data
        
    elif isinstance(network_data, nx.Graph):
        # Convert NetworkX to CX2Network
        factory = NetworkXToCX2NetworkFactory()
        cx2_network = factory.get_cx2network(network_data)
        
    elif isinstance(network_data, dict) or isinstance(network_data, list):
        # Create CX2Network from dict/list
        factory = RawCX2NetworkFactory()
        cx2_network = factory.get_cx2network(network_data)
        
    else:
        raise TypeError(f"Unsupported network data type: {type(network_data)}")
    
    # Extract network information
    name = cx2_network.get_name() or "Unnamed Network"
    attributes = cx2_network.get_network_attributes()
    node_count = len(cx2_network.get_nodes())
    edge_count = len(cx2_network.get_edges())
    
    # Collect attribute information
    attr_declarations = cx2_network.get_attribute_declarations()
    
    # Build information dictionary
    info = {
        "name": name,
        "node_count": node_count,
        "edge_count": edge_count,
        "attributes": attributes,
        "has_visual_properties": False
    }
    
    # Check for visual properties
    cx2_data = cx2_network.to_cx2()
    for item in cx2_data:
        if "visualProperties" in item:
            info["has_visual_properties"] = True
            break
    
    # Check for propagation weights
    # This indicates this is a propagation result
    if (attr_declarations and "nodes" in attr_declarations 
        and "propagation_weight" in attr_declarations["nodes"]):
        info["has_propagation_weights"] = True
    else:
        info["has_propagation_weights"] = False
    
    return info
